One way to enforce cybersecurity processes automatically is to define constraints to be met before a specific operation such as a workflow state transition is allowed. Cyberismo logic programs can define the following predicates to deny workflow transitions, moving cards, removing cards, or editing a field of a card.

== Workflow transition constraint

To deny a workflow transition, a user-defined logic program can define the following predicate:

[source]
----
transition_denied( <card key>, <transition name>, <error message> )
----

== Constraint to move a card

To deny moving a card, a user-defined logic program can define the following predicate:

[source]
----
moving_card_denied( <source card key>, <destination card key>, <error message> )
----

== Constraint to remove a card

To deny removing a card, a user-defined logic program can define the following predicate:

[source]
----
removing_card_denied( <card key>, <error message>)
----

== Constraint to edit a card

To deny editing a card field, a user-defined logic program can define the following predicate:

[source]
----
editing_field_denied( <card key>, <field name>, <error message> )
----

In this constraint, the field name `description` refers to the AsciiDoc contents of the card description.

== Example

For example, the requirement SM-5 of IEC 62443-4-1 requires that there must be a process to review security requirements by representatives of architects, testers, customer advocates, and security advisors. Let us assume that we represent security requirements as cards, and that the security requirement template includes four child cards that track the reviews of the requirement by these four roles, so all security requirements will automatically include these child cards. We can deny a workflow transition to accept a security requirement unless all review subtasks have been completed with the following logic program:

[source]
----
transition_denied(X, "approve",
    "Cannot approve this requirement, because not all review subtasks have been closed.") :-
    field(X, "cardtype", "security-requirement"),
    parent(Y, X),
    field(Y, "cardtype", "task"),
    not field(Y, "workflowState", "Closed").
----

The rule illustrates the use of default negation "not": the denial is generated by default unless the review substasks are all closed.
