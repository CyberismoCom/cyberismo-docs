This page introduces the power Cyberismo query language.

== Basic example

Let's get started with Cyberismo queries by a simple example that returns the title of all cards of the card type `base/page` in alphabetical order:

[source]
----
select("title"). <1>
result(Card) :- card(Card), field(Card, "cardtype", "base/page"). <2>
order_by("title", "ASC"). <3>
----
<1> Return the title field. Notice the period at the end of each line.
<2> Include `Card` in the results if the card type field equals `base/page`
<3> Sort the results by the title field in an ascending order.

== Selecting the fields of the results

The results of the queries are identified by a _key_, which is typically a card key. To return selected attributes of a key, use the `select` or `select_all` predicate.

For example, to include the fields `title` and  `workflowState`, you can use:

[source]
----
select("title";"workflowState").
----

Which is equivalent to:

[source]
----
select("title").
select("workflowState").
----

To select all fields in the results, use:

[source]
----
select_all.
----

== Selecting the results

The `result(X)` predicate denotes that `X` will be included in the results of the query. The following query returns all fields of entity (most likely a card) that has the key `docs_33`:

[source]
----
select_all.
result(docs_33).
----

Logic program rules are used to select results that match a condition. For example, the following query returns all cards that are in the workflow state `Open`.


[source]
----
select_all.
result(Card) :- card(Card), field(Card, "workflowState", "Open").
----

The `card(Card)` predicate is included to make sure that all returned entities are cards.

=== Conjunction (logical and)

A logic program rule can include several conditions that are separated by a comma. Such a rule is a _conjunction_, as it requires all conditions to be true, so it corresponds to the logical _and_ operator. For example, the following query returns all cards that are of the card type `base/page` _and_ have the workflow state `Open`. 

[source]
----
select_all.
result(Card) :- 
    card(Card), 
    field(Card, "cardtype", "base/page",
    field(Card, "workflowState", "Open").
----

=== Disjunction (logical or)

To implement a _disjunction_, which returns results for which at least one of the conditions is true, use multiple rules. The following query returns all cards that are either of the card type `base/page` _or_ have the workflow state `Open`, corresponisng to the logical _or_ operator.

[source]
----
select_all.
result(Card) :- 
    card(Card), 
    field(Card, "cardtype", "base/page".
result(Card) :- 
    card(Card), 
    field(Card, "workflowState", "Open").
----

== Ordering the results

The results of the query can be ordered by one or more fields in an ascending or descending order. 

There is no default order, but the Cyberismo query language requires you to explicitly include either the ascending (`"ASC"`) or descending (`"DESC"`) direction.

To order by one, two or three fields, you can use the `order_by` predicate. For example:

[source]
----
order_by("title", "ASC").
----

Or:

[source]
----
order_by("workflowState", "ASC", "title", "DESC").
----

Or:

[source]
----
order_by(
    "workflowState", "DESC", 
    "rank", "ASC", 
    "title", "ASC").
----

If you need to order by more than three fields, then use the `order` predicate. The previous example can be written equivalently with three order predicates as follows:

[source]
----
order(1, 1, "workflowState", "DESC").
order(1, 2, "rank", "ASC").
order(1, 3, "title", "ASC").
----

The parameters of the `order` predicate are:

1. The level of hierarchy of the results that will be sorted. When the query is not hierarchical, this is 1.
1. The index of the field by which to sort. For example, the index 1 means that you should first order by the field given in this occurrence of the `order` predicate.
1. The field by which the results should be ordered
1. Either `"ASC"` or `"DESC"`.

== Summary queries

The _key_ of the results does not always have to be a card key. For example, the following summary query works similarly to an SQL query that uses "GROUP BY", as it returns the different workflow states of the cards that are descendants of `docs_9`, and for each workflow state, it calculates a `count` attribute that contains the number of cards in the given state. Notice that it is this query that introduces the `count` attribute, rather than selecting a pre-existing attribute.


[source]
----
select_all.
result(State) :-
    ancestor(Card, docs_9),
    field(Card, "workflowState", State).

field(State, "count", Count) :-
    result(State),
    Count = #count { card(X) :
        ancestor(X, docs_9),
        field(X, "workflowState", State)
    }.
----

== Hierarchical queries

So far, the results of our queries have formed a flat list. A hierarchical query returns a tree structure: each result may have list of child results, which in turn may have child results.

For example, say we would like to query the children and grandchildren of `docs_9` according to the the card tree hierarchy. We would like the direct children to form the first level of hierarchy, and each child would have their children as child results. This can be done with the following query: 

[source]
----
select("title"). <1>
select(2, "title"). <2>
result(Card) :- parent(Card, docs_9).
child_result(Child, Grandchild) :- parent(Grandchild, Child), result(Child). <3>
order_by("title", "ASC"). <4>
order_by(2, "title", ASC). <5>
----
<1> `select` with just one parameter refers to the first level of hierarchy
<2> the first parameter indicates the level of hierarchy and the second parameter indicates, which fields to select on the given level.
<3> Child results are returned with the `child_result` predicate
<4> When `order_by` has an even number of parameters, it refers to the results on the highest level of hierarchy
<5> When `order_by` has an odd number of parameters, the first parameter denotes the level of hierarchy.
