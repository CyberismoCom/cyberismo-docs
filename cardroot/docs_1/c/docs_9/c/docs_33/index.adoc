Cyberismo has a powerful query language based on Answer Set Programming.

== Basic example

Let's get started with Cyberismo queries by a simple example that returns the title all cards of the card type `base/page` in alphabetical order:

[source]
----
select("title"). <1>
result(Card) :- card(Card), field(Card, "cardtype", "base/page"). <2>
order_by("title", "ASC"). <3>
----
<1> Return the title field. Notice the period at the end of each line.
<2> Include `Card` in the results if the card type field equals `base/page`
<3> Sort the results by the title field in an ascending order.

== Selecting the fields of the results

The results of the queries are identified by a _key_, which is typically a card key. To return selected attributes of a key, use the `select` or `select_all` predicate.

For example, to include the fields `title` and  `workflowState`, you can use:

[source]
----
select("title";"workflowState").
----

Which is equivalent to:

[source]
----
select("title").
select("workflowState").
----

To select all fields in the results, use:

[source]
----
select_all.
----

== Selecting the results

The `result(X)` predicate denotes that `X` will be included in the results of the query. The following query returns all fields of the card that has the card key `docs_33`:

[source]
----
select_all.
result(docs_33).
----

Logic program rules are used to select results that match a condition. For example, the following query returns all cards that are in the workflow state `Open`.


[source]
----
select_all.
result(Card) :- card(Card), field(Card, "workflowState", "Open").
----

The `card(Card)` predicate is included to make sure that all returned entities are cards.

=== Conjunction (logical and)

A logic program rule can include several conditions that are separated by a comma. Such a rule is a _conjunction_, as it requires all conditions to be true, so it corresponds to the logical and operation. For example, the following query returns all cards that are of the card type `base/page` and have the workflow state `Open`. 

[source]
----
select_all.
result(Card) :- 
    card(Card), 
    field(Card, "cardtype", "base/page",
    field(Card, "workflowState", "Open").
----

=== Disjunction (logical or)

To implement a _disjunction_, which returns results for which at least one of the conditions is true, use multiple rules. The following query returns all cards that are either of the card type `base/page` or have the workflow state `Open`.

[source]
----
select_all.
result(Card) :- 
    card(Card), 
    field(Card, "cardtype", "base/page".
result(Card) :- 
    card(Card), 
    field(Card, "workflowState", "Open").
----

== Ordering the results

The results of the query can be ordered by one or more fields in an ascending or descending order. 

There is no default order, but the Cyberismo query language requires you to explicitly include either the ascending (`"ASC"`) or descending (`"DESC"`) direction.

To order by one, two or three fields, you can use the `order_by` predicate. For example:

[source]
----
order_by("title", "ASC").
----

Or:

[source]
----
order_by("workflowState", "ASC", "title", "DESC").
----

Or:

[source]
----
order_by(
    "workflowState", "DESC", 
    "rank", "ASC", 
    "title", "ASC").
----

If you need to order by more than three fields, then use the `order` predicate. The previous example can be written with three order predicates as follows:

[source]
----
order(1, 1, "workflowState", "DESC").
order(1, 2, "rank", "ASC").
order(1, 3, "title", "ASC").
----

The parameters of the `order` predicate are:

1. The hierarchy level of the results that will be sorted. When the query is not hierarchical, this is 1.
1. The index of the field by which to sort. For example, the index 1 means that you should first order by the field given in this occurrence of the `order` predicate.
1. The field by which the results should be ordered
1. Either `"ASC"` or `"DESC"`.

== Summary queries

The _key_ of the results does not always have to be a card key. For example, the following summary query works similarly to an SQL query that uses "GROUP BY", as it returns the different workflow states of the cards that are descendants of ´docs_9´, and for each workflow state, it includes a `count` attribute that contains the number of cards in the given state.


[source]
----
select_all.
result(State) :-
    ancestor(Card, docs_9),
    field(Card, "workflowState", State).

field(State, "count", Count) :-
    result(State),
    Count = #count{ card(X) : ancestor(X, docs_9), field(X, "workflowState", State)}.
